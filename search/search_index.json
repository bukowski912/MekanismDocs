{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome Welcome the site! Please navigate around using the menu at the top of the page. Official Links For the Official GitHub, visit here . For the Official Wiki, visit here .","title":"Home"},{"location":"#welcome","text":"Welcome the site! Please navigate around using the menu at the top of the page.","title":"Welcome"},{"location":"#official-links","text":"For the Official GitHub, visit here . For the Official Wiki, visit here .","title":"Official Links"},{"location":"systems/","text":"Systems Heat System ( WIP ) Multiblocks","title":"Systems"},{"location":"systems/#systems","text":"Heat System ( WIP ) Multiblocks","title":"Systems"},{"location":"multiblocks/multiblocks/","text":"Multiblocks Mekanism incorporates several multiblocks into its core gameplay. They are listed below, for reference. By mod / abbreviation Mekanism Dynamic Tank (DT) Induction Matrix (IM) Supercritical Phase Shifter (SPS) Thermal Evaporation Plant (TEP) Thermoelectric Boiler (TB) Mekanism Generators Fission Reactor (FiR) Fusion Reactor (FuR) Industrial Turbine (IT) By category Crafting-related Supercritical Phase Shifter [synthesizes Antimatter] Thermal Evaporation Plant [makes Brine & Lithium] Fission Reactor [outputs Nuclear Waste as a byproduct] Storage-related Dynamic Tank [stores fluids] Induction Matrix [stores energy] Power-related Thermoelectric Boiler [exchanges heat between coolants] Fission Reactor [casts heat from nuclear fission into coolant] Fusion Reactor [makes power from nuclear fusion] Industrial Turbine [turns steam into power] By progression Thermal Evaporation Plant [to produce useful substances] Induction Matrix [to store the reams of energy obtained later] Industrial Turbine [to convert steam from the FiR / TB into power] Fission Reactor [to create steam for the IT] Thermoelectric Boiler [for sodium-cooling the FiR] Fusion Reactor [to generate ungodly amounts of power] Supercritical Phase Shifter [to create Antimatter] By constitution Any glass : either Reactor Glass or Structural Glass . Multiblock Constituents Dynamic Tank (frame) Dynamic <Tank / Valve> Any glass Induction Matrix (frame) Induction <Casing / Port> Any glass Induction Matrix (inner) Induction <Provider / Cell> Air Thermal Evaporation Plant Thermal Evaporation <Block / Valve / Controller> Advanced Solar Generator Thermoelectric Boiler (frame) Boiler <Casing / Valve> Any glass Thermoelectric Boiler (inner) Pressure Disperser Superheating Element Air Fission Reactor (frame) Fission Reactor <Casing / Port / Logic Adapter> Reactor Glass Fission Reactor (inner) <Fission Fuel / Control Rod> Assembly Air Fusion Reactor Fusion Reactor <Frame / Port / Controller / Logic Adapter> Laser Focus Matrix Reactor Glass Industrial Turbine (frame) Turbine <Casing / Valve / Vent> Any glass Industrial Turbine (inner) Turbine <Rotor / Blades> Rotational Complex Pressure Disperser Electromagnetic Coil Saturating Condenser Air","title":"Multiblocks"},{"location":"multiblocks/multiblocks/#multiblocks","text":"Mekanism incorporates several multiblocks into its core gameplay. They are listed below, for reference.","title":"Multiblocks"},{"location":"multiblocks/multiblocks/#by-mod-abbreviation","text":"","title":"By mod / abbreviation"},{"location":"multiblocks/multiblocks/#mekanism","text":"Dynamic Tank (DT) Induction Matrix (IM) Supercritical Phase Shifter (SPS) Thermal Evaporation Plant (TEP) Thermoelectric Boiler (TB)","title":"Mekanism"},{"location":"multiblocks/multiblocks/#mekanism-generators","text":"Fission Reactor (FiR) Fusion Reactor (FuR) Industrial Turbine (IT)","title":"Mekanism Generators"},{"location":"multiblocks/multiblocks/#by-category","text":"","title":"By category"},{"location":"multiblocks/multiblocks/#crafting-related","text":"Supercritical Phase Shifter [synthesizes Antimatter] Thermal Evaporation Plant [makes Brine & Lithium] Fission Reactor [outputs Nuclear Waste as a byproduct]","title":"Crafting-related"},{"location":"multiblocks/multiblocks/#storage-related","text":"Dynamic Tank [stores fluids] Induction Matrix [stores energy]","title":"Storage-related"},{"location":"multiblocks/multiblocks/#power-related","text":"Thermoelectric Boiler [exchanges heat between coolants] Fission Reactor [casts heat from nuclear fission into coolant] Fusion Reactor [makes power from nuclear fusion] Industrial Turbine [turns steam into power]","title":"Power-related"},{"location":"multiblocks/multiblocks/#by-progression","text":"Thermal Evaporation Plant [to produce useful substances] Induction Matrix [to store the reams of energy obtained later] Industrial Turbine [to convert steam from the FiR / TB into power] Fission Reactor [to create steam for the IT] Thermoelectric Boiler [for sodium-cooling the FiR] Fusion Reactor [to generate ungodly amounts of power] Supercritical Phase Shifter [to create Antimatter]","title":"By progression"},{"location":"multiblocks/multiblocks/#by-constitution","text":"Any glass : either Reactor Glass or Structural Glass . Multiblock Constituents Dynamic Tank (frame) Dynamic <Tank / Valve> Any glass Induction Matrix (frame) Induction <Casing / Port> Any glass Induction Matrix (inner) Induction <Provider / Cell> Air Thermal Evaporation Plant Thermal Evaporation <Block / Valve / Controller> Advanced Solar Generator Thermoelectric Boiler (frame) Boiler <Casing / Valve> Any glass Thermoelectric Boiler (inner) Pressure Disperser Superheating Element Air Fission Reactor (frame) Fission Reactor <Casing / Port / Logic Adapter> Reactor Glass Fission Reactor (inner) <Fission Fuel / Control Rod> Assembly Air Fusion Reactor Fusion Reactor <Frame / Port / Controller / Logic Adapter> Laser Focus Matrix Reactor Glass Industrial Turbine (frame) Turbine <Casing / Valve / Vent> Any glass Industrial Turbine (inner) Turbine <Rotor / Blades> Rotational Complex Pressure Disperser Electromagnetic Coil Saturating Condenser Air","title":"By constitution"},{"location":"systems/heat-system/","text":"The Heat System Introduction This document chronicles the design and development of a (relatively) principled heat system. The main reason for it is as a potential resort to the numerous difficulties and shortcomings of the current offering. The document is split into two main sections: core concepts and technical details . The former provides some background and an overview, whilst the latter dives deeper into how such a system might be implemented, along with any other miscellaneous concerns. Preliminaries (Feel free to skip to the next section if you either don\u2019t care or already know the stuff.) A little bit of thermodynamics Thermodynamic systems can be measured and categorised in many ways. For now, we are most interested in the basic physical quantities, such as temperature (K, \u00b0C, \u00b0F), heat energy (J, kJ), specific heat capacity (J/g-K), heat capacity (J/K), and mass (g, kg). Here\u2019s a couple ways they\u2019re related: heat capacity = specific heat \u00d7 mass temperature = heat energy \u00f7 heat capacity heat energy = temperature \u00d7 heat capacity There are a few other quantities like thermal conductivity and resistivity which are important when modelling heat flow as a function of time, and are used in e.g. Fourier\u2019s law , but are beyond the scope of this document. A little bit of simulation Heating simulations in many ways resemble physics-sims you\u2019ll find in most large game engines. Each thing (or body) in the system tracks two important variables: position and velocity . During every epoch (or tick) the velocity is cumulatively modified by (perhaps several) applications of impulse force. At the end of each tick, when all is said and done, the velocity is added to the position and cleared, and thus a single iteration of chosen simulation method is concluded. It is much the same way with a heat-sim, except that position and velocity are replaced by stored heat and heat flux , respectively. Core Concepts The proposed system works with several fundamental concepts and objects. Here they are briefly defined, with more details given later. A handy shopping list of components: Heat capacitors Heat contacts Heat manifolds Heat islands Heat handlers (TODO) Heat Capacitor The most basic unit of heat storage. Capacitors store heat in the form of energy (J); they are also ascribed a heat capacity and various thermal properties ( thermals ) such as conductivity and insulation, which govern their behaviour through heat contacts . Thermals may be provided for the entire capacitor (directionless) or for any direction representing a side of that capacitor. Heat Contact A building block of inter- capacitor thermodynamics. In a nutshell: contacts facilitate heat traffic between one or more capacitors. In practice, they serve two overlapping purposes: to introduce heat energy into the system; to thermally bond a group of capacitors. Heat Manifold The interconnection of a single heat capacitor to any other capacitors, via heat contacts . Manifolds are convenient for modelling heat at the scale of a multi-faceted device, such as a heater, reactor, boiler, etc. While a device itself may only manage a single capacitor, a manifold for it will manage the connections that capacitor may have to external elements, such as adjacent tiles, the environment, and so on. Heat Island An aggregation of the above components into a single structure, constrained to a single network of heat-supporting devices. It exists for the most part to optimize the entire simulation (especially at a large scale) and is otherwise not essential to the system. Technical Details Heat Capacitor For the sake of numerical simulation, each heat capacitor stores a delta heatToHandle which accumulates individual transfers of heat energy that take place within a tick. This task is assigned to the handleHeat() instance method. By the end of the tick, this quantity is dumped into the total storedHeat of the capacitor. This task is assigned to the updateHeat() instance method. Heat capacitors are outlined by the IHeatCapacitor interface, and basically implemented by the BasicHeatCapacitor class. Heat Contact Although the heat-contact interface is general enough to support any number of degrees of contact, there are currently only two types of contacts defined, which should serve most if not all use cases: monadic (single-capacitor)\u2014outlined by the IMonadicHeatContact interface; dyadic (double-capacitor)\u2014outlined by the IDyadicHeatContact interface. Contacts may be directional, in that each member capacitor may have an associated direction. This is useful in representing the facets of a capacitor, such as the sides of a block/tile containing one. An example of a monadic contact is an environmental connection. Here is a sample of the simulate() instance method for such a contact: @Override public double simulate(long currentTime) { double invConduction = Thermals.environmentConduction(source, side); double tempToTransfer = (source.getTemperature() - HeatAPI.AMBIENT_TEMP) / invConduction; source.handleHeat(-tempToTransfer * source.getHeatCapacity()); return Math.max(0, tempToTransfer); } (Notice that only a single capacitor source and direction side is needed for this type of contact. Also note that the method takes a currentTime parameter. This will be explained later.) An example of a dyadic contact is an adjacent connection. Here is a sample of the simulate() instance method for such a contact: @Override public double simulate(long currentTime) { double invConduction = Thermals.adjacentConduction(this); double tempToTransfer = (second.getTemperature() - first.getTemperature()) / invConduction; double heatToTransfer = tempToTransfer * first.getHeatCapacity(); first.handleHeat(-heatToTransfer); second.handleHeat(heatToTransfer); return tempToTransfer; } (Notice that two capacitors [and implicitly two directions]\u2014one which is opposite the other\u2014are employed for this type of contact.) An example for the Thermal Evaporation Plant is provided at the end . Heat Manifold The design of the heat manifold promotes contact sharing through its methods, which cuts down on memory usage and simplifies some of the simulation concerns. However, as a contact instance may be tracked by multiple manifolds (doing double-duty ), further concessions may need to be made. Since it is assumed that no contact be simulated twice in the same way within a tick, manifolds should reasonably have idempotent countermeasures. This can be achieved by the addition of a lastSimulationTime variable, which (unsurprisingly) keeps track of the game time of the last simulation tick; and upon being requested to simulate again during the same tick, simply does nothing. To aid in this, the simulate() method takes a currentTime argument, which is obtained by the caller (most likely from Level#getGameTime() ) and passed through the call chain. Heat Island In the way of optimization, an island can maintain an internal collection of capacitors and interfaces, which it efficiently iterates through every tick, rather than, say, having to peruse every manifold which would in most cases repeat-visit contacts. Examples Thermal Evaporation Plant Following is a possible implementation of IMonadicHeatContact for use by the Thermal Evaporation Plant. Disclaimer: This has in large part been lifted from the existing implementation; there is potential for improvement. public class EvaporationHeatContact implements IMonadicHeatContact { private long lastSimulationTime = -1; private final IntSupplier activeSolarsSupplier; private final DoubleSupplier ambientTempSupplier; public EvaporationHeatContactBasic(IHeatCapacitor heatCapacitor, IntSupplier activeSolarsSupplier, DoubleSupplier ambientTempSupplier) { super(heatCapacitor); this.activeSolarsSupplier = activeSolarsSupplier; this.ambientTempSupplier = ambientTempSupplier; } protected double getAmbientTemperature() { return ambientTempSupplier == null ? HeatAPI.AMBIENT_TEMP : ambientTempSupplier.getAsDouble(); } @Override public double simulate(long currentTime) { if (currentTime <= lastSimulationTime) { return; } lastSimulationTime = currentTime; double currentTemp = getCapacitor().getTemperature(); int activeSolars = activeSolarsSupplier.getAsInt(); double ambientTemp = getAmbientTemperature(); double heatCapacity = getCapacitor().getHeatCapacity(); capacitor.handleHeat(activeSolars * MekanismConfig.general.evaporationSolarMultiplier.get() * heatCapacity); if (Math.abs(currentTemp - ambientTemp) < 0.001) { capacitor.handleHeat(ambientTemp * heatCapacity - capacitor.getHeat()); } else { double incr = MekanismConfig.general.evaporationHeatDissipation.get() * Math.sqrt(Math.abs(currentTemp - ambientTemp)); if (currentTemp > ambientTemp) { incr = -incr; } capacitor.handleHeat(heatCapacity * incr); if (incr < 0) { return -incr; } } return 0; } }","title":"The Heat System"},{"location":"systems/heat-system/#the-heat-system","text":"","title":"The Heat System"},{"location":"systems/heat-system/#introduction","text":"This document chronicles the design and development of a (relatively) principled heat system. The main reason for it is as a potential resort to the numerous difficulties and shortcomings of the current offering. The document is split into two main sections: core concepts and technical details . The former provides some background and an overview, whilst the latter dives deeper into how such a system might be implemented, along with any other miscellaneous concerns.","title":"Introduction"},{"location":"systems/heat-system/#preliminaries","text":"(Feel free to skip to the next section if you either don\u2019t care or already know the stuff.)","title":"Preliminaries"},{"location":"systems/heat-system/#a-little-bit-of-thermodynamics","text":"Thermodynamic systems can be measured and categorised in many ways. For now, we are most interested in the basic physical quantities, such as temperature (K, \u00b0C, \u00b0F), heat energy (J, kJ), specific heat capacity (J/g-K), heat capacity (J/K), and mass (g, kg). Here\u2019s a couple ways they\u2019re related: heat capacity = specific heat \u00d7 mass temperature = heat energy \u00f7 heat capacity heat energy = temperature \u00d7 heat capacity There are a few other quantities like thermal conductivity and resistivity which are important when modelling heat flow as a function of time, and are used in e.g. Fourier\u2019s law , but are beyond the scope of this document.","title":"A little bit of thermodynamics"},{"location":"systems/heat-system/#a-little-bit-of-simulation","text":"Heating simulations in many ways resemble physics-sims you\u2019ll find in most large game engines. Each thing (or body) in the system tracks two important variables: position and velocity . During every epoch (or tick) the velocity is cumulatively modified by (perhaps several) applications of impulse force. At the end of each tick, when all is said and done, the velocity is added to the position and cleared, and thus a single iteration of chosen simulation method is concluded. It is much the same way with a heat-sim, except that position and velocity are replaced by stored heat and heat flux , respectively.","title":"A little bit of simulation"},{"location":"systems/heat-system/#core-concepts","text":"The proposed system works with several fundamental concepts and objects. Here they are briefly defined, with more details given later. A handy shopping list of components: Heat capacitors Heat contacts Heat manifolds Heat islands Heat handlers (TODO)","title":"Core Concepts"},{"location":"systems/heat-system/#heat-capacitor","text":"The most basic unit of heat storage. Capacitors store heat in the form of energy (J); they are also ascribed a heat capacity and various thermal properties ( thermals ) such as conductivity and insulation, which govern their behaviour through heat contacts . Thermals may be provided for the entire capacitor (directionless) or for any direction representing a side of that capacitor.","title":"Heat Capacitor"},{"location":"systems/heat-system/#heat-contact","text":"A building block of inter- capacitor thermodynamics. In a nutshell: contacts facilitate heat traffic between one or more capacitors. In practice, they serve two overlapping purposes: to introduce heat energy into the system; to thermally bond a group of capacitors.","title":"Heat Contact"},{"location":"systems/heat-system/#heat-manifold","text":"The interconnection of a single heat capacitor to any other capacitors, via heat contacts . Manifolds are convenient for modelling heat at the scale of a multi-faceted device, such as a heater, reactor, boiler, etc. While a device itself may only manage a single capacitor, a manifold for it will manage the connections that capacitor may have to external elements, such as adjacent tiles, the environment, and so on.","title":"Heat Manifold"},{"location":"systems/heat-system/#heat-island","text":"An aggregation of the above components into a single structure, constrained to a single network of heat-supporting devices. It exists for the most part to optimize the entire simulation (especially at a large scale) and is otherwise not essential to the system.","title":"Heat Island"},{"location":"systems/heat-system/#technical-details","text":"","title":"Technical Details"},{"location":"systems/heat-system/#heat-capacitor_1","text":"For the sake of numerical simulation, each heat capacitor stores a delta heatToHandle which accumulates individual transfers of heat energy that take place within a tick. This task is assigned to the handleHeat() instance method. By the end of the tick, this quantity is dumped into the total storedHeat of the capacitor. This task is assigned to the updateHeat() instance method. Heat capacitors are outlined by the IHeatCapacitor interface, and basically implemented by the BasicHeatCapacitor class.","title":"Heat Capacitor"},{"location":"systems/heat-system/#heat-contact_1","text":"Although the heat-contact interface is general enough to support any number of degrees of contact, there are currently only two types of contacts defined, which should serve most if not all use cases: monadic (single-capacitor)\u2014outlined by the IMonadicHeatContact interface; dyadic (double-capacitor)\u2014outlined by the IDyadicHeatContact interface. Contacts may be directional, in that each member capacitor may have an associated direction. This is useful in representing the facets of a capacitor, such as the sides of a block/tile containing one. An example of a monadic contact is an environmental connection. Here is a sample of the simulate() instance method for such a contact: @Override public double simulate(long currentTime) { double invConduction = Thermals.environmentConduction(source, side); double tempToTransfer = (source.getTemperature() - HeatAPI.AMBIENT_TEMP) / invConduction; source.handleHeat(-tempToTransfer * source.getHeatCapacity()); return Math.max(0, tempToTransfer); } (Notice that only a single capacitor source and direction side is needed for this type of contact. Also note that the method takes a currentTime parameter. This will be explained later.) An example of a dyadic contact is an adjacent connection. Here is a sample of the simulate() instance method for such a contact: @Override public double simulate(long currentTime) { double invConduction = Thermals.adjacentConduction(this); double tempToTransfer = (second.getTemperature() - first.getTemperature()) / invConduction; double heatToTransfer = tempToTransfer * first.getHeatCapacity(); first.handleHeat(-heatToTransfer); second.handleHeat(heatToTransfer); return tempToTransfer; } (Notice that two capacitors [and implicitly two directions]\u2014one which is opposite the other\u2014are employed for this type of contact.) An example for the Thermal Evaporation Plant is provided at the end .","title":"Heat Contact"},{"location":"systems/heat-system/#heat-manifold_1","text":"The design of the heat manifold promotes contact sharing through its methods, which cuts down on memory usage and simplifies some of the simulation concerns. However, as a contact instance may be tracked by multiple manifolds (doing double-duty ), further concessions may need to be made. Since it is assumed that no contact be simulated twice in the same way within a tick, manifolds should reasonably have idempotent countermeasures. This can be achieved by the addition of a lastSimulationTime variable, which (unsurprisingly) keeps track of the game time of the last simulation tick; and upon being requested to simulate again during the same tick, simply does nothing. To aid in this, the simulate() method takes a currentTime argument, which is obtained by the caller (most likely from Level#getGameTime() ) and passed through the call chain.","title":"Heat Manifold"},{"location":"systems/heat-system/#heat-island_1","text":"In the way of optimization, an island can maintain an internal collection of capacitors and interfaces, which it efficiently iterates through every tick, rather than, say, having to peruse every manifold which would in most cases repeat-visit contacts.","title":"Heat Island"},{"location":"systems/heat-system/#examples","text":"","title":"Examples"},{"location":"systems/heat-system/#thermal-evaporation-plant","text":"Following is a possible implementation of IMonadicHeatContact for use by the Thermal Evaporation Plant. Disclaimer: This has in large part been lifted from the existing implementation; there is potential for improvement. public class EvaporationHeatContact implements IMonadicHeatContact { private long lastSimulationTime = -1; private final IntSupplier activeSolarsSupplier; private final DoubleSupplier ambientTempSupplier; public EvaporationHeatContactBasic(IHeatCapacitor heatCapacitor, IntSupplier activeSolarsSupplier, DoubleSupplier ambientTempSupplier) { super(heatCapacitor); this.activeSolarsSupplier = activeSolarsSupplier; this.ambientTempSupplier = ambientTempSupplier; } protected double getAmbientTemperature() { return ambientTempSupplier == null ? HeatAPI.AMBIENT_TEMP : ambientTempSupplier.getAsDouble(); } @Override public double simulate(long currentTime) { if (currentTime <= lastSimulationTime) { return; } lastSimulationTime = currentTime; double currentTemp = getCapacitor().getTemperature(); int activeSolars = activeSolarsSupplier.getAsInt(); double ambientTemp = getAmbientTemperature(); double heatCapacity = getCapacitor().getHeatCapacity(); capacitor.handleHeat(activeSolars * MekanismConfig.general.evaporationSolarMultiplier.get() * heatCapacity); if (Math.abs(currentTemp - ambientTemp) < 0.001) { capacitor.handleHeat(ambientTemp * heatCapacity - capacitor.getHeat()); } else { double incr = MekanismConfig.general.evaporationHeatDissipation.get() * Math.sqrt(Math.abs(currentTemp - ambientTemp)); if (currentTemp > ambientTemp) { incr = -incr; } capacitor.handleHeat(heatCapacity * incr); if (incr < 0) { return -incr; } } return 0; } }","title":"Thermal Evaporation Plant"}]}